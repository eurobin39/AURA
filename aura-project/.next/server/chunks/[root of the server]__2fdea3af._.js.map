{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///Users/eurobae/AURA/Aura/aura-project/lib/session.ts"],"sourcesContent":["import { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\n\ninterface SessionContent {\n    id?: number;\n}\n\nexport default async function getSession() {\n    const cookieStore = await cookies();\n    return getIronSession<SessionContent>(cookieStore, {\n        cookieName: \"delicious-karrot\",\n        password: process.env.COOKIE_PASSWORD!,\n    });\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAMe,eAAe;IAC1B,MAAM,cAAc,MAAM,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD;IAChC,OAAO,CAAA,GAAA,kJAAA,CAAA,iBAAc,AAAD,EAAkB,aAAa;QAC/C,YAAY;QACZ,UAAU,QAAQ,GAAG,CAAC,eAAe;IACzC;AACJ","debugId":null}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/eurobae/AURA/Aura/aura-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst db = new PrismaClient();\n\nexport default db;"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,KAAK,IAAI,6HAAA,CAAA,eAAY;uCAEZ","debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///Users/eurobae/AURA/Aura/aura-project/lib/ai-service.ts"],"sourcesContent":["import { AzureOpenAI } from \"openai\";\nimport { DefaultAzureCredential, getBearerTokenProvider } from \"@azure/identity\";\n\n// Simplified Azure OpenAI client for hackathon\nexport class AuraAIService {\n  private client: AzureOpenAI;\n  \n  constructor() {\n    const deployment = process.env.AZURE_OPENAI_DEPLOYMENT || \"\";\n    const endpoint = process.env.AZURE_OPENAI_ENDPOINT || \"\";\n    const apiKey = process.env.AZURE_OPENAI_API_KEY || \"\";\n    const apiVersion = \"2024-10-21\";\n    \n    // Use API key instead of Azure AD token\n    this.client = new AzureOpenAI({\n      apiKey,\n      deployment,\n      apiVersion,\n      endpoint\n    });\n  }\n  \n  async generateFocusInsights(\n    activityData: { \n      keystrokes: number, \n      clicks: number, \n      mouseMoved: number,\n      activeApps: string[],\n      sessionDuration: number,\n      timeOfDay: string\n    }\n  ) {\n    const prompt = `\n    ## User Work Session Data\n    - Keystrokes: ${activityData.keystrokes}\n    - Mouse clicks: ${activityData.clicks}\n    - Mouse movement: ${activityData.mouseMoved}px\n    - Active applications: ${activityData.activeApps.join(', ')}\n    - Session duration: ${activityData.sessionDuration} minutes\n    - Time of day: ${activityData.timeOfDay}\n    \n    Based on this work session data, provide:\n    1. A short analysis of the user's work patterns (2-3 sentences)\n    2. Three specific, actionable tips to improve focus and productivity\n    3. One insight about optimal working conditions for this person\n    \n    Format the response as JSON with keys: \"analysis\", \"tips\" (array), and \"insight\".\n    `;\n    \n    const response = await this.client.completions.create({\n      model: process.env.AZURE_OPENAI_DEPLOYMENT || \"\",\n      prompt: [prompt],\n      max_tokens: 500,\n      temperature: 0.7\n      }\n    );\n    \n    try {\n      return JSON.parse(response.choices[0].text);\n    } catch (e) {\n      console.error(\"Failed to parse AI response\", e);\n      return {\n        analysis: \"Unable to analyze work session.\",\n        tips: [\"Take regular breaks\", \"Stay hydrated\", \"Minimize distractions\"],\n        insight: \"Consider tracking more data for better insights.\"\n      };\n    }\n  }\n}\n\nexport const aiService = new AuraAIService(); "],"names":[],"mappings":";;;;AAAA;;AAIO,MAAM;IACH,OAAoB;IAE5B,aAAc;QACZ,MAAM,aAAa,QAAQ,GAAG,CAAC,uBAAuB,IAAI;QAC1D,MAAM,WAAW,QAAQ,GAAG,CAAC,qBAAqB,IAAI;QACtD,MAAM,SAAS,QAAQ,GAAG,CAAC,oBAAoB,IAAI;QACnD,MAAM,aAAa;QAEnB,wCAAwC;QACxC,IAAI,CAAC,MAAM,GAAG,IAAI,kJAAA,CAAA,cAAW,CAAC;YAC5B;YACA;YACA;YACA;QACF;IACF;IAEA,MAAM,sBACJ,YAOC,EACD;QACA,MAAM,SAAS,CAAC;;kBAEF,EAAE,aAAa,UAAU,CAAC;oBACxB,EAAE,aAAa,MAAM,CAAC;sBACpB,EAAE,aAAa,UAAU,CAAC;2BACrB,EAAE,aAAa,UAAU,CAAC,IAAI,CAAC,MAAM;wBACxC,EAAE,aAAa,eAAe,CAAC;mBACpC,EAAE,aAAa,SAAS,CAAC;;;;;;;;IAQxC,CAAC;QAED,MAAM,WAAW,MAAM,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YACpD,OAAO,QAAQ,GAAG,CAAC,uBAAuB,IAAI;YAC9C,QAAQ;gBAAC;aAAO;YAChB,YAAY;YACZ,aAAa;QACb;QAGF,IAAI;YACF,OAAO,KAAK,KAAK,CAAC,SAAS,OAAO,CAAC,EAAE,CAAC,IAAI;QAC5C,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;gBACL,UAAU;gBACV,MAAM;oBAAC;oBAAuB;oBAAiB;iBAAwB;gBACvE,SAAS;YACX;QACF;IACF;AACF;AAEO,MAAM,YAAY,IAAI","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///Users/eurobae/AURA/Aura/aura-project/lib/session-tracker.ts"],"sourcesContent":["import db from \"./db\";\nimport { aiService } from \"./ai-service\";\n\n// Simplified session tracking for hackathon\nexport class SessionTracker {\n  private static instance: SessionTracker;\n  private activeSession: any = null;\n  private keyCount: number = 0;\n  private clickCount: number = 0;\n  private mouseDistance: number = 0;\n  private activeApps: Set<string> = new Set();\n  \n  // Singleton pattern\n  public static getInstance(): SessionTracker {\n    if (!SessionTracker.instance) {\n      SessionTracker.instance = new SessionTracker();\n    }\n    return SessionTracker.instance;\n  }\n  \n  // Start a new work session\n  async startSession(userId: number): Promise<any> {\n    if (this.activeSession) {\n      await this.endSession();\n    }\n    \n    this.resetCounters();\n    \n    // Verify that the user exists first\n    const user = await db.user.findUnique({\n      where: { id: userId }\n    });\n    \n    if (!user) {\n      console.error(`Cannot start session: User with ID ${userId} does not exist`);\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    \n    // Create new session in database\n    this.activeSession = await db.workSession.create({\n      data: {\n        userId,\n        startTime: new Date(),\n        activeApps: []\n      }\n    });\n    \n    return this.activeSession;\n  }\n  \n  // End current session and generate insights\n  async endSession(): Promise<any> {\n    if (!this.activeSession) return null;\n    \n    // Update only the fields that we know exist in the schema\n    const updatedSession = await db.workSession.update({\n      where: { id: this.activeSession.id },\n      data: {\n        endTime: new Date(),\n        activeApps: Array.from(this.activeApps)\n        // Removed fields that might not be in the schema:\n        // keystrokes, mouseClicks, mouseDistance, focusScore\n      }\n    });\n    \n    // Get AI-generated insights\n    const aiInsights = await this.generateInsights(updatedSession);\n    \n    // Reset the active session\n    this.activeSession = null;\n    \n    return {\n      session: updatedSession,\n      insights: aiInsights\n    };\n  }\n  \n  // Track keyboard activity\n  trackKeyPress(): void {\n    if (!this.activeSession) return;\n    this.keyCount++;\n  }\n  \n  // Track mouse clicks\n  trackMouseClick(): void {\n    if (!this.activeSession) return;\n    this.clickCount++;\n  }\n  \n  // Track mouse movement\n  trackMouseMove(distance: number): void {\n    if (!this.activeSession) return;\n    this.mouseDistance += distance;\n  }\n  \n  // Track active application\n  trackApplication(appName: string): void {\n    if (!this.activeSession) return;\n    this.activeApps.add(appName);\n  }\n  \n  // Calculate focus score (simplified algorithm)\n  private calculateFocusScore(): number {\n    const keyScore = Math.min(this.keyCount / 300, 1.0) * 0.5;\n    const clickScore = Math.min(this.clickCount / 100, 1.0) * 0.2;\n    const moveScore = Math.min(this.mouseDistance / 5000, 1.0) * 0.3;\n    \n    return Math.round((keyScore + clickScore + moveScore) * 100);\n  }\n  \n  // Generate AI insights from session data\n  private async generateInsights(session: any): Promise<any> {\n    try {\n      const duration = session.endTime \n        ? Math.round((session.endTime.getTime() - session.startTime.getTime()) / 60000) \n        : 0;\n      \n      const timeOfDay = this.getTimeOfDay(session.startTime);\n      \n      // Get insights from Azure OpenAI\n      const aiResponse = await aiService.generateFocusInsights({\n        keystrokes: this.keyCount,\n        clicks: this.clickCount,\n        mouseMoved: this.mouseDistance,\n        activeApps: session.activeApps,\n        sessionDuration: duration,\n        timeOfDay\n      });\n      \n      // Skip database insertion for now to avoid schema mismatch issues\n      // Return the AI insights directly instead\n      return {\n        analysis: aiResponse.analysis,\n        tips: aiResponse.tips,\n        insight: aiResponse.insight,\n        focusScore: this.calculateFocusScore(),\n        date: new Date()\n      };\n      \n      // NOTE: Uncomment and fix this once the Prisma schema and TypeScript definitions are in sync\n      /*\n      const insight = await db.focusInsight.create({\n        data: {\n          // Add the correct fields based on your schema\n        }\n      });\n      return insight;\n      */\n    } catch (error) {\n      console.error(\"Failed to generate insights:\", error);\n      return null;\n    }\n  }\n  \n  // Get time of day category\n  private getTimeOfDay(date: Date): string {\n    const hour = date.getHours();\n    \n    if (hour >= 5 && hour < 12) return \"morning\";\n    if (hour >= 12 && hour < 17) return \"afternoon\";\n    if (hour >= 17 && hour < 21) return \"evening\";\n    return \"night\";\n  }\n  \n  // Reset all counters\n  private resetCounters(): void {\n    this.keyCount = 0;\n    this.clickCount = 0;\n    this.mouseDistance = 0;\n    this.activeApps = new Set();\n  }\n}\n\nexport const sessionTracker = SessionTracker.getInstance();"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///Users/eurobae/AURA/Aura/aura-project/app/api/focus-sessions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport getSession from '@/lib/session';\nimport db from '@/lib/db';\nimport { sessionTracker } from '@/lib/session-tracker';\n\n// Start a new focus session\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getSession();\n    const userId = session.id;\n    \n    if (!userId) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const newSession = await sessionTracker.startSession(userId);\n    \n    return NextResponse.json({ \n      success: true, \n      message: 'Session started successfully',\n      sessionId: newSession.id \n    });\n  } catch (error) {\n    console.error('Failed to start session:', error);\n    return NextResponse.json({ error: 'Failed to start session' }, { status: 500 });\n  }\n}\n\n// End current focus session\nexport async function PUT(request: NextRequest) {\n  try {\n    const session = await getSession();\n    const userId = session.id;\n    \n    if (!userId) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const result = await sessionTracker.endSession();\n    \n    if (!result) {\n      return NextResponse.json({ error: 'No active session found' }, { status: 404 });\n    }\n    \n    return NextResponse.json({ \n      success: true, \n      message: 'Session ended successfully',\n      session: result.session,\n      insights: result.insights\n    });\n  } catch (error) {\n    console.error('Failed to end session:', error);\n    return NextResponse.json({ error: 'Failed to end session' }, { status: 500 });\n  }\n}\n\n// Get user's focus sessions history\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getSession();\n    const userId = session.id;\n    \n    if (!userId) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const sessions = await db.workSession.findMany({\n      where: { userId },\n      include: { insights: true },\n      orderBy: { startTime: 'desc' },\n      take: 10\n    });\n    \n    return NextResponse.json({ \n      success: true, \n      sessions \n    });\n  } catch (error) {\n    console.error('Failed to fetch sessions:', error);\n    return NextResponse.json({ error: 'Failed to fetch sessions' }, { status: 500 });\n  }\n} "],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,gHAAA,CAAA,UAAU,AAAD;QAC/B,MAAM,SAAS,QAAQ,EAAE;QAEzB,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,aAAa,MAAM,2HAAA,CAAA,iBAAc,CAAC,YAAY,CAAC;QAErD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,WAAW,WAAW,EAAE;QAC1B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA0B,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACF;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,gHAAA,CAAA,UAAU,AAAD;QAC/B,MAAM,SAAS,QAAQ,EAAE;QAEzB,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,SAAS,MAAM,2HAAA,CAAA,iBAAc,CAAC,UAAU;QAE9C,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,SAAS,OAAO,OAAO;YACvB,UAAU,OAAO,QAAQ;QAC3B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,gHAAA,CAAA,UAAU,AAAD;QAC/B,MAAM,SAAS,QAAQ,EAAE;QAEzB,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,WAAW,MAAM,2GAAA,CAAA,UAAE,CAAC,WAAW,CAAC,QAAQ,CAAC;YAC7C,OAAO;gBAAE;YAAO;YAChB,SAAS;gBAAE,UAAU;YAAK;YAC1B,SAAS;gBAAE,WAAW;YAAO;YAC7B,MAAM;QACR;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAChF;AACF","debugId":null}},
    {"offset": {"line": 523, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}